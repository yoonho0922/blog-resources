## SOLID 원칙

좋은 객체지향 설계를 만들기 위한 기본 원칙들

* **SRP (단일 책임 원칙: Single Responsibility Principle)**
* **OCP (개방 폐쇄의 원칙: Open Close Principle)**
* **LSP (리스코프 치환 원칙: The Liskov Substitution Principle)**
* **ISP (인터페이스 분리의 원칙: Interface Segregation Principle)**
* **DIP (의존성 역전의 원칙: Dependency Inversion Principle)**



## SRP

#### 단일 책임 원칙

* **하나의 클래스가 하나의 기능**만 가지고 있도록 설계 - 독립성
  *  **하나의 변경 이유**만을 갖도록 설계
    * **The Audience**(해당 클래스를 사용하려는 무언가) 찾기
  * 가장 기본적이지만 가장 직접 구현하기 어려운 원칙


#### 적용 방법

* **Extract Class**
  * 한 클래스 안에 이의 **구조를 변경토록 하는 이유가 둘 이상** 존재하는 경우
  * ex) 학생 클래스를 성적정보, 재학 정보, 등록금 납입 정보 필드를 갖도록 **클래스 추출**
* **Extract Superclass**
  * 클래스를 나누고 보니 **유사한 책임**을 나눠 맡고 있는 경우 -> 상속
  * 대학생 성적정보, 대학원생 성적정보 클래스 -> 성적 정보 **클래스를 상속**하도록
* **Shotgun Surgery**
  * 흩어진 메소드 들과 필드를 한 클래스로 합침
  * 매우 어려운 방법이고, 최후의 수단임

## OCP

#### 개방 폐쇄 원칙

* **확장에 대해 Open**

* **변경에 대해 Close**

* 코드를 **변경하지 않고 확장할 수 있도록** 설계한다
  * 요구사항 변경 발생: 새 클래스를 만들어 붙이거나 상속 등을 통해 클래스 재사용
* **변경 대상**과 **불변 대상**을 명확히 구분
  * 변경대상과 불변 대상 사이에 인터페이스 정의
  * 구상 클래스 대신 인터페이스를 통해 코드 작성
    * 전략 패턴 strategy pattern (SRP, OCP를 만족시키는 디자인 패턴)

##  LSP

#### 리스코프 치환 원칙

* **자식 타입은 부모 타입의 정의를 위반해서는 안된다**
* **리스코프 치환**: 자식 타입 클래스는 언제나 **부모 타입 클래스로 바꿔 끼울 수 있어야** 한다
* 가능하다면 언제나 **인터페이스(최상위 클래스)**를 사용해서 프로그래밍 할 것

#### 적용 방법

* 복수의 객체가 **같은 일을 한다면** 둘을 **하나의 클래스로 묶고** 이들을 구분할 수 있는 필드 생성
  * ex) 직사각형, 정사각형
* 같은 **연산을 약간씩 다르게** 한다면 **공통 인터페이스**를 만들고 이를 구현
  * ex) 사각형, 원
* 공통 연산 외에 **약간의 차이**를 가진다면, **상속**을 통해 구현
  * ex) 가득 찬 원, 빈 원

#### Override 주의보

* 부모 클래스의 메소드를 **override로 재정의할 때**, **그 양상이 완전히 달라진다면**
  * **인터페이스를 이용해야 했거나**
  * 사실은 **부모-자식 사이가 아니었거나**

## ISP

#### 인터페이스 분리의 원칙

* **자신이 사용하지 않을 인터페이스는 구현하지 말 것**
  * 응집성과 연관
* 하나의 일반적인 인터페이스 보다는**, 여러개의 구체적인 인터페이스**가 좋음
  * 인터페이스의 **단일 책임**
  * Animal 인터페이스 보다는 Barkable, Walkable, Eatable 인터페이스 권장

#### 적용 방법

* 클래스 **상속**을 통한 인터페이스 분리
* 상속 대신 **위임**을 사용
  * 퍼사드 패턴 Facade Pattern

## DIP

#### 의존성 역전의 원칙

* 하위(Calle)가 상위(Caller)에 의존해야 함
* **하위 모듈이 상위 모듈의 변경을 요구해서는 안됨**
  * ex) Auido(상위) 모듈이 Speaker(하위) 모듈의 speak() 메소드를 사용하고 있었는데, Speaker 모듈이 Headphone 모듈로 바뀌려면 Audio의 변경 발생

----

reference

* 상명대학교 한종대교수님 소프트웨어공학 수업